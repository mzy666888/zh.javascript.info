在 `6.35` 内部，小数部分是一个无限的二进制。在这种情况下，它的存储会存在一个精度的损失。

让我们来看看：

```js run
alert( 6.35.toFixed(20) ); // 6.34999999999999964473
```

精度损失可能会导致数字的增加和减小。在这种特殊情况下，数字可能会变小了一点，这就是为什么它减小了。

那么 `1.35` 是怎样的呢？

```js run
alert( 1.35.toFixed(20) ); // 1.35000000000000008882
```

在这里，精度损失使得这个数字更大了一些，所以这个数字变大了一些。

**如果我们希望以正确的方式四舍五入，我们如何使用 `6.35` 为例来解决这个问题？**

在四舍五入之前，我们应该使它更接近整数：

```js run
alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
```

请注意 `63.5` 完全没有精度缺失。这是因为小数部分 `0.5` 实际上是 `1/2`。以 2 为分母的分数在二进制系统中可以被精确地表示，现在我们可以对它进行四舍五入了：


```js run
alert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
```
